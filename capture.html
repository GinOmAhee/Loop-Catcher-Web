<!DOCTYPE html>
<html lang="en">
<head>
<link rel="icon" href="data:,">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ü™Ñ New Thought</title>
  <style>
    :root {
      --natural-beige: #f5f1e8;
      --soft-plum: #774C64;
      --muted-green: #6B8F71;
    }
    .theme-calm {
      background-color: #f3f7f4;
      color: #4C5B52;
    }

    .theme-strategic {
      background-color: #f1f0ed;
      color: #2E2E2E;
    }

    .theme-reflective {
      background-color: #fffefc;
      color: #3e3e3e;
    }

    .theme-bold {
      background-color: #fef6ec;
      color: #5C2F00;
    }

    .theme-playful {
      background-color: #fff0f7;
      color: #64204f;
    }
    
    .mic-btn.listening {
      border: 2px solid var(--muted-green);
      box-shadow: 0 0 12px 4px rgba(107, 143, 113, 0.5);
      background: #84a48f;
      transition: box-shadow 0.3s ease;
    }

    .interim-text {
      margin-top: 1rem;
      font-style: italic;
      font-size: 0.9rem;
      color: #999;
      min-height: 1.2rem;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', sans-serif;
      background: var(--natural-beige);
      color: var(--soft-plum);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      height: 100vh;
      text-align: center;
    }

    h2 {
      font-size: 1.6rem;
      margin-bottom: 0.25rem;
    }

    .nudge {
      font-style: italic;
      font-size: 0.95rem;
      color: #555;
      margin-bottom: 1.5rem;
    }

    textarea {
      width: 100%;
      max-width: 500px;
      height: 140px;
      padding: 1rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 10px;
      resize: vertical;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }

    button {
      margin-top: 1rem;
      padding: 0.8rem 1.5rem;
      font-size: 1rem;
      background: var(--muted-green);
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }

    button:hover {
      background: #5c7e63;
    }
  </style>
</head>
<body>
  <div id="loadingMessage">üîÑ Checking login status‚Ä¶</div>

  <div id="mainContent" style="display: none;">
    <h2>+ New Thought</h2>
    <p id="moodLabel" style="font-size: 0.9rem; margin-bottom: 1.2rem; color: inherit;"></p>
    <p class="nudge">üí° Sudden spark? Jot it here ‚Äî we got you.</p>

    <textarea id="thoughtInput" placeholder="Type your thought‚Ä¶"></textarea>
    <button id="captureBtn">Capture Thought</button>
    <button id="speakSaveBtn" class="mic-btn">üéôÔ∏è Speak & Save</button>
    <div id="interimTranscript" class="interim-text"></div>
  </div>

  <script type="module">
  const fetchFirebaseConfig = async () => {
    try {
      const res = await fetch("https://us-central1-loop-catcher-firebase.cloudfunctions.net/getAPIKey");
      const config = await res.json();

      if (!config.projectId) {
        throw new Error("Missing projectId in Firebase config.");
      }
      return config;
    } catch (err) {
      console.error("Failed to fetch Firebase config:", err);
      alert("Could not load app config. Try again later.");
      return null; // Prevents Firebase initialization with incomplete data
    }
  };

   // üåà Mood Mirror Logic
   const moodThemeMap = {
     "Calm & Clear": "theme-calm",
     "Focused & Strategic": "theme-strategic",
     "Open & Reflective": "theme-reflective",
     "Driven & Bold": "theme-bold",
     "Playful & Inventive": "theme-playful"
   };

   window.addEventListener("DOMContentLoaded", () => {
    const label = (localStorage.getItem("vibeLabel") || "").trim();
    const themeClass = moodThemeMap[label];

    const moodLabelEl = document.getElementById("moodLabel");
    if (moodLabelEl && label) moodLabelEl.textContent = `${label} Mode`;

    if (themeClass) {
      document.body.classList.add(themeClass);
    } else {
      console.warn("No matching mood theme found:", label);
    }

    const init = async () => {
      const firebaseConfig = await fetchFirebaseConfig();
      console.log("Firebase Config Loaded:", firebaseConfig);

      if (!firebaseConfig) {
        console.error("Firebase initialization aborted due to missing config.");
        return;
      }

     const { initializeApp } = await import("https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js");
     const { getFirestore, collection, addDoc, serverTimestamp } = await import("https://www.gstatic.com/firebasejs/11.9.1/firebase-firestore.js");
     const { getAuth, onAuthStateChanged, signInWithEmailAndPassword } = await import("https://www.gstatic.com/firebasejs/11.9.1/firebase-auth.js");

     const app = initializeApp(firebaseConfig);
     const db = getFirestore(app);
     const auth = getAuth(app);

     console.log("Current user before auth state change:", auth.currentUser);

     // üéôÔ∏è VOICE TO TEXT: Setup
       const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
       const recognition = new SpeechRecognition();
       recognition.lang = 'en-US';
       recognition.interimResults = false; // Set to true if you want live text
       recognition.maxAlternatives = 1;

       speakBtn.addEventListener("click", () => {
         recognition.start();
         speakBtn.textContent = "üéôÔ∏è Listening...";
       });

       recognition.onresult = (event) => {
         const transcript = event.results[0][0].transcript;
         thoughtInput.value += (thoughtInput.value ? " " : "") + transcript;
         speakBtn.textContent = "üéôÔ∏è Speak Thought";
         // Optionally: auto-trigger save
         thoughtInput.dispatchEvent(new Event("input"));
       };

    recognition.onerror = (event) => {
       console.error("Speech recognition error:", event.error);
       alert("Speech error: " + event.error);
       speakBtn.textContent = "üéôÔ∏è Speak Thought";
    };

    recognition.onend = () => {
       speakBtn.textContent = "üéôÔ∏è Speak Thought";
    };
    // Add this in recognition setup
    recognition.continuous = false; // Keep off for mobile
    recognition.stopTimeout = setTimeout(() => recognition.stop(), 6000); // ‚è±Ô∏è ~6 sec buffer

    recognition.onstart = () => {
    clearTimeout(recognition.stopTimeout);
    recognition.stopTimeout = setTimeout(() => recognition.stop(), 6000);
    };

  }

     auth.onAuthStateChanged(async (user) => {
       console.log("User state before reload:", user);
       if (user) {
         await user.reload();
         console.log("User after reload:", user);
       } else {
         window.location.href = "signin.html";
         return;
       }

       // üëâ SHOW THE MAIN UI
       const loadingMessage = document.getElementById("loadingMessage");
       const mainContent = document.getElementById("mainContent");
       const captureBtn = document.getElementById("captureBtn");
       const thoughtInput = document.getElementById("thoughtInput");
       const speakSaveBtn = document.getElementById("speakSaveBtn");
       const interimTranscript = document.getElementById("interimTranscript");

       if (!('webkitSpeechRecognition' in window)) {
         speakSaveBtn.style.display = "none";
         console.warn("SpeechRecognition not supported");
       } else {
         const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
         const recognition = new SpeechRecognition();
         recognition.lang = 'en-US';
         recognition.interimResults = true;
         recognition.maxAlternatives = 1;
         recognition.continuous = false; // Keep false but use workaround below

         let finalTranscript = "";

         speakSaveBtn.addEventListener("click", () => {
           finalTranscript = "";
           interimTranscript.textContent = "";
           recognition.start();
           speakSaveBtn.textContent = "üéôÔ∏è Listening...";
           speakSaveBtn.classList.add("listening");
         });

         recognition.onresult = (event) => {
           let interim = "";
           for (let i = event.resultIndex; i < event.results.length; ++i) {
             const res = event.results[i];
             if (res.isFinal) {
               finalTranscript += res[0].transcript + " ";
             } else {
               interim += res[0].transcript;
             }
         }
         interimTranscript.textContent = interim;
       };

       recognition.onend = async () => {
        speakSaveBtn.textContent = "üéôÔ∏è Speak & Save";
        speakSaveBtn.classList.remove("listening");

        if (finalTranscript.trim()) {
          thoughtInput.value += (thoughtInput.value ? " " : "") + finalTranscript.trim();
          updateStatus("üíæ Saving...");
          await saveToFirestore(); // Triggers auto-save
          interimTranscript.textContent = "";
        } else {
          interimTranscript.textContent = "No input detected.";
        }
      };

      recognition.onerror = (event) => {
        console.error("Speech recognition error:", event.error);
        speakSaveBtn.textContent = "üéôÔ∏è Speak & Save";
        speakSaveBtn.classList.remove("listening");
        interimTranscript.textContent = "‚ö†Ô∏è Error: " + event.error;
      };
    }

       loadingMessage.style.display = "none";
       mainContent.style.display = "block";

       // ‚úÖ AUTOSAVE SECTION STARTS HERE
       const statusEl = document.createElement("div");
       statusEl.style.fontSize = "0.8rem";
       statusEl.style.marginTop = "0.5rem";
       statusEl.style.color = "#888";
       thoughtInput.insertAdjacentElement("afterend", statusEl);

       const draftKey = `draft-${user.uid}`;
       let saveTimeout;
       let lastSavedAt = null;

       const updateStatus = (text) => {
         statusEl.textContent = text;
       };

       const saveToFirestore = async () => {
         const content = thoughtInput.value.trim();
         if (!content) return;

         try {
           await addDoc(collection(db, "catchpad"), {
             content,
             owner: user.uid,
             createdAt: serverTimestamp()
           });
           const now = new Date();
           lastSavedAt = now.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
           updateStatus(`‚úÖ Saved ‚úì at ${lastSavedAt}`);
           localStorage.setItem(draftKey, content);
         } catch (err) {
           console.error("Firestore save failed:", err);
           updateStatus("‚ö†Ô∏è Offline ‚Äî will retry later");
           localStorage.setItem(draftKey, content);
         }
      };

  // ‚å®Ô∏è Auto-save every few keystrokes
  thoughtInput.addEventListener("input", () => {
    updateStatus("üíæ Saving...");
    clearTimeout(saveTimeout);
    saveTimeout = setTimeout(saveToFirestore, 1500);
  });

  // üß† Restore from localStorage if tab reloads
  const savedDraft = localStorage.getItem(draftKey);
  if (savedDraft && !thoughtInput.value.trim()) {
    const restore = confirm("Restore previous unsaved thought?");
    if (restore) {
      thoughtInput.value = savedDraft;
      updateStatus("üí° Restored draft from backup");
    }
  }

  // üñ± Manual capture button
  function handleCaptureClick() {
    const entry = thoughtInput.value.trim();
    if (!entry) return;

    addDoc(collection(db, "catchpad"), {
      content: entry,
      owner: user.uid,
      createdAt: serverTimestamp()
    })
      .then(() => {
        window.location.href = "catchpad.html";
      })
      .catch((error) => {
        console.error("Error saving thought:", error);
        alert("Oops! Couldn‚Äôt save your thought. Try again.");
      });

     }

  captureBtn.addEventListener("click", handleCaptureClick);

     signInWithEmailAndPassword(auth, "testuser@example.com", "password123")
       .then((userCredential) => console.log("Login successful:", userCredential.user))
       .catch((error) => console.error("Login failed:", error));
   };

   // ‚úÖ Move this line inside the DOMContentLoaded listener
   init();
 });
</script>
</body>
</html>
